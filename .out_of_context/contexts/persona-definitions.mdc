---
type: methodology
roles:
- scientist
- developer
name: persona-definitions
created_at: '2025-12-16T12:37:15.280304'
---

# Persona Definitions - Database Layer Project

## Two-Persona Approach

This project uses a **two-persona design methodology** to separate concerns:

---

## ML Scientist Persona

**Responsibilities:**
- Define evaluation methodology and metrics
- Create evaluation test sets with relevance judgments
- Measure baseline and semantic search performance
- Validate quality improvements with statistical rigor
- Make acceptance/rejection recommendations

**Ownership:**
- WHAT constitutes "good retrieval" (define success criteria)
- WHAT metrics to use (Precision@5, Recall@5, MRR, NDCG)
- WHETHER the system meets targets (validation)

**NOT Responsible For:**
- Implementation details (API, schema, libraries)
- Technology choices (which vector database)
- Code design and architecture

**Action Items:** (docs/v1/database/scientist/)
1. Create evaluation test set (50+ queries)
2. Run baseline evaluation (substring search)
3. Evaluate semantic search and make acceptance decision

---

## Developer Persona

**Responsibilities:**
- Choose implementation technologies (vector database, file watcher)
- Design APIs, schemas, and architecture
- Implement semantic search functionality
- Measure and optimize performance
- Fix bugs and handle edge cases

**Ownership:**
- HOW to implement requirements (design decisions)
- WHICH technologies to use (within constraints)
- WHETHER implementation meets performance targets

**NOT Responsible For:**
- Defining what "good retrieval" means (scientist's job)
- Creating evaluation test sets
- Statistical validation of quality

**Action Items:** (docs/v1/database/developer/)
1. Choose vector database (ChromaDB/LanceDB/SQLite)
2. Implement MVP semantic search
3. Implement file synchronization
4. Validate performance (latency < 100ms)
5. Validate convergence (< 10s)

---

## Key Principle: Separation of WHAT vs HOW

**Scientist defines WHAT:**
- Requirements (with evidence)
- Constraints (scale, latency, consistency)
- Success criteria (>30% improvement, p < 0.05)
- Interface requirements (must integrate with MCP)

**Developer defines HOW:**
- Technology choices (database, libraries)
- API design (new tool vs modify existing)
- Schema design (how to store embeddings)
- Implementation details

**Both collaborate on:**
- Edge cases and failure modes
- Tradeoffs (performance vs complexity)
- Iterating when targets not met

---

## Why This Structure?

1. **Maintains scientific rigor:** Evidence-based requirements, statistical validation
2. **Preserves developer autonomy:** Design freedom within constraints
3. **Clear accountability:** Who decides what
4. **Enables parallel work:** Can work simultaneously with clear handoffs
